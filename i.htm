<!doctype html>
    <span id=t style="position:absolute;color:white;"></span>
    <canvas id=c style="background:#000;position:aboslute">
<style>
    body{margin:0}
</style>
<script>
    
    function displayCrash() {
        console.log("crash !")

    }
    
    function displayMission() {
        
    }
    
    
    
    
missions = [
    {n:'iss',r:'soyouz'},
    {n:'apollo',r:'saturn V'},
    {n:'spaceMars',r:'vulcain9'},
]    
mousePos = new v2d(0,0)

Number.prototype.m = function(n){return((this%n)+n)%n;}

var vPool=[]
for(var i = 0;i < 200; i++) {
    vPool[i]={
        speed : new v2d(0,0),
        f : 0,
        pos : new v2d()
        
    }
}

function v2d(x,y) {
    this.x = x
    this.y = y
    this.tmp = 1;//for buff & swap
}
    
    v2d.prototype.setPoint = function(x,y) {
        this.x = x
        this.y = y
    }
     
    
    v2d.prototype.setVector = function(v) {
        this.x = v.x
        this.y = v.y
    }
    
v2d.prototype.X = function(o){
    this.x=this.x*o.x;
    this.y=this.y*o.y;
}

v2d.prototype.normalize = function() {
    this.tmp = this.x;
    this.x  = this.x / Math.hypot(this.x,this.y)
    this.y = this.y / Math.hypot(this.tmp,this.y)
}

v2d.prototype.add = function(o){
    this.x=this.x+o.x;
    this.y=this.y+o.y;
}

v2d.prototype.sub = function(o){
    this.x=this.x-o.x;
    this.y=this.y-o.y;
}

v2d.prototype.scale = function(n){
    this.x=this.x*n;this.y=this.y*n;
}
    
v2d.prototype.toString = function() {
    return 'x:'+this.x+'|y:'+this.y
}

v2d.prototype.x = function() {
    return this.x
}

v2d.prototype.y = function() {
    return this.y
}

v2d.prototype.stance = function(o) {
    return Math.sqrt(
        (this.y-o.y)*(this.y-o.y)+  
        (this.x-o.x)*(this.x-o.x)
    )
}
v2d.prototype.norm = function() {
    return Math.hypot(this.x,this.y)
}

oldDate = new Date();
nz = 10
sun = {pos : new v2d(0,0), stance: 0, name : 'sun', G : 18000, color : "#ffffff"}
stars = []
g = function(x,player,planets){  
    
    tools = {
        mouse : new v2d(0,0),
        cam : new v2d(0,0),
        screen : new v2d(c.width/2,c.height/2),    
    },
    manover = {
        nearPoint : null,
        minStance : 0,
        stance : 0,
        origin : new v2d(0,0),
        deltaV : new v2d(0,0),
        state : 0
    },  
    
    player = {
        gravity : {
            normamizedGravity : new v2d(0,0),
            moveVector : new v2d(0,0)
        },
            
        trajectory : {
            apo : new v2d(0,0),
            peri : new v2d(0,0),
            stanceCurrent : new v2d(0,0),
            posCurrent : new v2d(0,0),
            normamizedGravity : new v2d(0,0),
            pos : new v2d(0,0),
            speed : new v2d(0,0),
            acc : new v2d(0,0),
            force : 0,
            forceCurrent : 0,    
            attratedBy : sun,
            attratedByCurrent : sun,
            futurePlanetStance : new v2d(0,0),
            moveVector : new v2d(0,0)
        },
        pos : new v2d(200,200),
        heading:Math.PI/2,
        agility:Math.PI/45,
        speed : new v2d(0,0),
        acc : new v2d(0,0),
        right:false,
        M:1000,
        mass : 1,
        left:false,
        thrustUp:false,
        
        linkedTo:null,
        attratedBy:null,
        
        stages:[
            {isOn:false, power:1.3, isCurrent:true}
        ],
        thrustDown:false,
        thrust : 0,
        move : function(delta){
            
            //landed
            if(player.linkedTo){
                player.pos.setPoint(player.linkedTo.pos.x,player.linkedTo.pos.y+player.linkedTo.diameter)
            } else {
                
                //collide
                planets.forEach(function(planet){
                    
                    if(player.pos.stance(planet.pos) < planet.diameter / 2) {
                        // collide 
                        // go get energy !
                        var choc = player.speed.norm() // approx energy     
                        if(choc >= 0) {
                            displayCrash()
                        } 
                    }
                })
                                    
                //gravity well                
                sun.stance = sun.pos.stance(player.pos)
                
                g = sun.G / (sun.stance * sun.stance)
                player.attratedBy = sun
                
                planets.forEach(function(planet) {
                    planet.stance = planet.pos.stance(player.pos)    
                    if((planet.G / (planet.stance * planet.stance)) > g) {
                        g = planet.G / (planet.stance * planet.stance)
                        player.attratedBy = planet
                    }
                })
                
                
                                
                player.gravity.normamizedGravity.setVector(player.attratedBy.pos)
                
                player.gravity.normamizedGravity.sub(player.pos)
                
                player.gravity.normamizedGravity.normalize()
                
                player.gravity.normamizedGravity.scale(g)
                
                
                
                //atmoshperic
                
                //engine
                if(player.stages[0].isOn) {
                
                    player.acc.setPoint(Math.cos(player.heading)*player.stages[0].power*player.thrust, 
                                         Math.sin(player.heading)*player.stages[0].power*player.thrust)
                }
                                
                player.acc.add(player.gravity.normamizedGravity)        
                player.speed.add(player.acc)


                player.gravity.moveVector.setVector(player.speed)
                player.gravity.moveVector.scale(0.16)

                player.pos.add(player.gravity.moveVector)
                
            } 
        },
        
        link : function(o) {
            player.linkedTo = o
            player.attratedBy = o
            player.pos.x = o.pos.x 
            player.pos.y = o.pos.y+(o.diameter/2)
        },
        
        stage : function() {
                player.stages[0].isOn = true
                console.log("Start engine")
                player.linkedTo = false
                player.speed.setPoint(0,0)
        },  
        
        draw : function(x) {
            
            //x.beginPath();
            x.fillStyle = "red"
            x.save()
            x.translate((c.width/2+z(player.pos.x- camera.pos.x))+z((5)) ,(c.height/2+z(player.pos.y- camera.pos.y)+z(10)))
            x.rotate(player.heading)
            x.fillRect(z(-10),z(-5),z(20),z(10))//
            
             x.fillStyle = "rgba(250,250,250,0.3)"

            for(var i = 0; i < 10; i++) {
                x.fillRect(c.width/2+z(player.pos.x- camera.pos.x)+z(5+ Math.random() * 10) ,c.height/2+z(player.pos.y- camera.pos.y)+z(10 + Math.random() * 10), z(10), z(10))
            }
            
            x.restore()
            
            var relativeSpeed = new v2d(player.speed.x,player.speed.y)
            t.innerHTML = "thrust : " + player.thrust + "|speed : " + player.speed.norm()
           
        }
    }
    player.toString = function() {
        return 'pos:'+player.pos.toString()+'|heading:'+player.heading+'|thrust:'+player.thrust
    }
    
    player.controll=function(delta){
        if(player.thrustUp&&!player.thrustDown) player.thrust = player.thrust >= 1 ? 1 : player.thrust+0.01    
        if(player.thrustDown&&!player.thrustUp) player.thrust = player.thrust <= 0 ? 0 : player.thrust-0.01 
        if(player.left&&!player.right) player.heading = player.heading >= 2*Math.PI ? 0 : player.heading+player.agility 
        if(player.right&&!player.left) player.heading = player.heading <= 0 ? 2*Math.PI : player.heading-player.agility    
    }
    

    function computeGravity(futureObect,futureTime) {
        player.trajectory.stance = player.trajectory.attratedBy.pos.stance(futureObect)
        player.trajectory.force = player.trajectory.attratedBy.G / (player.trajectory.stance * player.trajectory.stance)
        
        planets.forEach(function(planet) {
            var stanceZ = planet.getFuturePosition(futureTime).stance(futureObect)
            var forceZ = planet.G / (stanceZ * stanceZ)
            if(player.trajectory.force < forceZ) {
                player.trajectory.force = forceZ
                player.trajectory.attratedBy = planet
            }
        })
        
            stanceZ = futureObect.stance(sun.pos)

            forceZ = sun.G / (stanceZ * stanceZ)
            if(player.trajectory.force < forceZ) {
                player.trajectory.force = forceZ
                player.trajectory.attratedBy = sun
            }
        
        //return player.future.planet
    }
    
    
    
    function trajectory(context, deltaV, nearPoint) {
        if(nearPoint) {
            context.fillRect(c.width/2+z(nearPoint.pos.x-camera.pos.x+4),c.height/2+z(nearPoint.pos.y-camera.pos.y-5),8,8)            
            player.trajectory.pos.setVector(nearPoint.pos)
            player.trajectory.speed.setVector(deltaV)
        } else {
            player.trajectory.pos.setVector(player.pos)
            player.trajectory.speed.setVector(player.speed)
        }
        player.trajectory.attratedByCurrent = player.attratedBy
        // 200 should be enought
        var step = 100
        var breakFlag = false
        for(var i=0;i<200;i++) {
            if(breakFlag) {
                break;
            }
            
            
            // new acc
            player.trajectory.acc.setPoint(0,0)
       
            computeGravity(player.trajectory.pos, i*0.16*step)
            player.trajectory.normamizedGravity.setVector(player.trajectory.attratedBy.pos)
            player.trajectory.normamizedGravity.sub(player.trajectory.pos)
            player.trajectory.normamizedGravity.normalize()
            
        
            player.trajectory.normamizedGravity.scale(player.trajectory.force * step)
            
                            
            player.trajectory.speed.add(player.trajectory.normamizedGravity)
            
            // console.log(planet)
            player.trajectory.moveVector.setVector(player.trajectory.speed)
            player.trajectory.moveVector.scale(0.16*step)

            
            player.trajectory.pos.add(player.trajectory.moveVector)
            
            // for apo / peri
            vPool[i].pos.setVector(player.trajectory.pos)
            vPool[i].force = player.trajectory.force
            vPool[i].speed.setVector(player.trajectory.speed)     
            var dist = Math.hypot(player.pos.x-player.trajectory.pos.x, player.pos.y-player.trajectory.pos.y)
            if(dist < 100 && dist != 0) {
                // detect loop
                breakFlag = true
            }
            planets.forEach(function(planet){
                    
                    if(player.trajectory.pos.stance(planet.pos) < planet.diameter / 2) {
                        // collide 
                        // go get energy !
                        if(i > 10) {
                            breakFlag = true
                        }
                    }
                })
            
            
            // update color of trajectory if influence change
            context.fillStyle  = player.attratedBy.color
            if(player.trajectory.attratedByCurrent != player.trajectory.attratedBy) {
                player.trajectory.attratedByCurrent = player.trajectory.attratedBy
                context.fillStyle  = player.trajectory.attratedBy.color
            }
            if(nearPoint) {
                context.fillStyle = 'red'
            }
            context.fillRect(c.width/2+z(player.trajectory.pos.x-camera.pos.x+4),c.height/2+z(player.trajectory.pos.y-camera.pos.y-5),2,2)            
        }
        player.trajectory.apo = vPool[0].pos
        player.trajectory.peri = vPool[0].pos
        vPool.forEach(function(vp) {
            if(player.trajectory.apo.tmp > vp.tmp) {
                player.trajectory.apo = vp.pos
            }
            if(player.trajectory.peri.tmp < vp.tmp) {
                player.trajectory.peri = vp.pos
            }
        })
        // get apo and peri
        context.fillStyle = "#FFE659"
        context.fillRect(c.width/2+z(player.trajectory.peri.x-camera.pos.x+4),c.height/2+z(player.trajectory.peri.y-camera.pos.y-5),4,4)            
        context.fillStyle = "#FFE600"
        context.fillRect(c.width/2+z(player.trajectory.apo.x-camera.pos.x+4),c.height/2+z(player.trajectory.apo.y-camera.pos.y-5),4,4)            

        
    }
    
    function navBall(context){
   
        var a1 = new v2d(player.attratedBy.pos.x, player.attratedBy.pos.y)
        a1.sub(player.pos)
        var sheepH = Math.atan2(a1.y,a1.x) + Math.PI 
        h = (player.heading - sheepH).m(2*Math.PI) / (Math.PI * 2) * 200 
        //h += 25
        //h = h.m(100)
        context.save()
        context.fillStyle = "#61C7FA"
        context.fillRect(c.width/2 - 50,c.height - h - 100,100,100)
        context.fillRect(c.width/2 - 50,c.height - h +100,100,100)
        context.fillStyle = "#6DDE70"
        context.fillRect(c.width/2 - 50,c.height - h,100,100)
        //context.fillRect(c.width/2 - 50,c.height - h - 150,100,50)
        //center    
        context.fillStyle = "#FFE659"
        context.fillRect(c.width/2 - 50,c.height - 50,30,3)   
        context.fillRect(c.width/2 + 20,c.height - 50,30,3)   
        
        //console.log(h)
        //context.globalCompositeOperation = "source-over"

        
        var playerAccHeading = Math.atan2(player.speed.y,player.speed.x) 
        var r = player.heading - playerAccHeading + Math.PI / 2
        
        context.fillStyle = "#FFFFFF"
        r = r.m(2*Math.PI) / (Math.PI * 2) * 200
        context.fillRect(c.width/2-5,c.height - r,10,10)
        context.fillStyle = "#FF0000"
        context.fillRect(c.width/2-5,c.height - (r + 100).m(200),10,10)
       
        context.fillStyle = "#ffffff"
            
        for(var i = 0;i<20;i++){
            // trace angle
                context.fillRect(c.width/2 - 5,c.height - (20 * i) - h + 200,10,1)   
                context.fillRect(c.width/2 - 2,c.height - (20 * i + 10) - h + 200,4,1)   
        }
        
        context.globalCompositeOperation = "destination-in"
        context.fillStyle = "#ffffff"
        context.fillRect(c.width/2 - 50,c.height - 100,100,100)
        
        context.restore()
        
            
    }
    
    document.onmousedown = function(e) {
        
        if(manover.state == 0) {
            manover.state = 1
        }       
        if(manover.state == 3) {
            manover.state = 0
        }
    }
    
    document.onmouseup = function() {
        if(manover.state == 2) {
            manover.state = 3
        }
    }
    
    function mouseToSpace() {
        
        tools.screen = new v2d(c.width/2,c.height/2) 
        tools.mouse.setVector(mousePos)
        tools.mouse.sub(tools.screen)
        tools.cam.setVector(camera.pos)
        tools.mouse.scale((1/nz)*10)
        tools.cam.add(tools.mouse)
        
    }
    
    
    function drawManover(context) {
        
        if(manover.state==1) {
            //get neareast point on trajectory
           mouseToSpace()
            //vMouse.sub(vCam)
           // vMouse.sub(vCam)
            manover.nearPoint = vPool[0]
            manover.minStance = vPool[0].pos.stance(tools.mouse)
            vPool.forEach(function(vp) {
                manover.stance = vp.pos.stance(tools.cam)
                if(manover.minStance > manover.stance) {
                    manover.minStance = manover.stance
                    manover.nearPoint = vp
                    manover.origin.setVector(mousePos)
                }
            })
            manover.state = 2
        } else if(manover.state==2) {
            manover.state = 2
            context.moveTo(c.width/2+z(manover.nearPoint.pos.x-camera.pos.x+4),c.height/2+z(manover.nearPoint.pos.y-camera.pos.y-5))
            context.arc(c.width/2+z(manover.nearPoint.pos.x-camera.pos.x+4),c.height/2+z(manover.nearPoint.pos.y-camera.pos.y-5),4,0,7)
            context.fillStyle = "white"
            context.fill()
            context.strokeStyle = "white"
            context.lineTo(mousePos.x,mousePos.y)
            context.stroke()
            manover.deltaV.setVector(mousePos)
            manover.deltaV.sub(manover.origin)
            manover.deltaV.add(manover.nearPoint.speed)
            trajectory(context, manover.deltaV, manover.nearPoint)
            document.title = manover.nearPoint.pos
        } else if(manover.state==3) {
            trajectory(context, manover.deltaV, manover.nearPoint)
            //draw alternateManover
        }
    }
    
    document.onkeydown=function(k) {
        if(k.keyCode==38 || k.keyCode==90){ /*up&z*/
            player.thrustUp = true//player.thrust>=100 ? 100 : player.thrust++ 
        }
        if(k.keyCode==40 || k.keyCode==83){ /*down&s*/
            player.thrustDown = true//player.thrust<=0 ? 0 : player.thrust- 
            player.thrustDown = true//player.thrust<=0 ? 0 : player.thrust- 
        }
        if(k.keyCode==37 || k.keyCode==81){ /*left&q*/
            player.left = true; 
        }
        if(k.keyCode==39 || k.keyCode==68){ /*right&d*/
            player.right = true 
        }
        // zoom on o & p
        if(k.keyCode == 79) {
            nz = nz <= 0 ? 0 : nz / 2
        }
        
        if(k.keyCode == 80) {
            nz = nz >= 1000 ? 1000 : nz * 2
        }
        if(k.keyCode == 32) {
            player.stage()
        }
    }
    
    document.onmousewheel = function() {
        
    }
    
    
    document.onmousemove = function(e) {
        mousePos.x = e.clientX
        mousePos.y = e.clientY
    }

    
    document.onkeyup=function(k) {
        if(k.keyCode==38 || k.keyCode==90){ /*up&z*/
            player.thrustUp = false
        }
        if(k.keyCode==40 || k.keyCode==83){ /*down&s*/
            player.thrustDown = false
        }
        if(k.keyCode==37 || k.keyCode==81){ /*left&q*/
            player.left = false; 
        }
        if(k.keyCode==39 || k.keyCode==68){ /*right&d*/
            player.right = false 
        }
    }

    
    
    x=c.getContext('2d')
    c.width=innerWidth-8;c.height=innerHeight-8
    planets=[]
    camera = player
	planets[0]=new Planet(0.000,800,null,9000,0,0,20000, 'blue', '#0000FF')
	planets[1]=new Planet(0.000,250,null,16000,0,0,8000, 'red', '#FF0000')
    player.link(planets[0])
    prepareStar()
    
    function l(){
        delta = new Date()-oldDate;
        oldDate = new Date()
        c.width^=0
        navBall(x)
        drawStars(x)
        drawManover(x)
        player.controll(delta)
        
        planets.forEach(function(planet) {
            planet.move(delta)
        })
        
        player.move(delta)
                
        planets.forEach(function(planet) {
            planet.draw(x)
        })
        trajectory(x)
        player.draw(x)     
        drawSun(x)
        requestAnimationFrame(l)
    }
    l()
}
/*
	Planet
	s self rotate speed
	S rotate speed
	d diameter
	ox origin x
	oy origin y
	r ressources
	D distance from origin
*/
function Planet(speed,diameter,parent,distanceMinFromParent,distanceMaxFromParent,angle,G,name, color){
    this.speed=speed
    this.stance = 0
    this.color = color
    this.G = G
    this.distanceMaxFromParent = distanceMaxFromParent  
    this.distanceMinFromParent = distanceMinFromParent
    this.diameter=diameter
    this.angle=angle
    this.pos=new v2d(Math.cos(this.angle)*this.distanceMinFromParent,Math.sin(this.angle)*this.distanceMinFromParent)
    this.name=name    
}
    
Planet.prototype.getSpeedVector = function() {
    
}
    
    
Planet.prototype.toString=function(){
    return this.name,'|speed:'+this.speed.toString()+'|pos:'+this.pos.toString()
}
    
Planet.prototype.draw=function(context){
    context.beginPath()
    //c.width/2+player.pos.x - camera.pos.x,c.height/2+player.pos.y - camera.pos.y
    context.arc(c.width/2+z(this.pos.x - camera.pos.x),c.height/2+z(this.pos.y - camera.pos.y),z(this.diameter),0,7)
    context.fillStyle = "blue";
    context.fill()
    context.closePath()
    //orbit
    context.beginPath()
    context.arc(c.width/2+z(-camera.pos.x),c.height/2+z(-camera.pos.y), z(this.distanceMinFromParent), 0, 7)
    context.strokeStyle = '#2A2D2E'
    context.stroke()
}
 
Planet.prototype.move=function(delta){
    this.angle = this.angle+delta*this.speed/100
    this.pos.x=Math.cos(this.angle)*this.distanceMinFromParent
    this.pos.y=Math.sin(this.angle)*this.distanceMinFromParent
}

Planet.prototype.getFuturePosition=function(delta){
    var angle = this.angle+delta*this.speed/100
    return new v2d(Math.cos(angle)*this.distanceMinFromParent,Math.sin(angle)*this.distanceMinFromParent)
}

function drawSun(x) {
    x.beginPath()
    x.arc(c.width/2-z(camera.pos.x),c.height/2-z(camera.pos.y),z(1000),0,7)
    x.fillStyle = "orange";
    x.fill()
    x.closePath()
}

function z(d){
    return (nz*d)/10
}
    
    
    function drawSky() {
        
    }
    
    function drawStars(context) {
        
        for(si in stars) {
            s = stars[si]
        
            context.moveTo(s.starX,s.starY)
            context.arc(s.starX,s.starY, s.intensity,0,7)
            //if(s.blink) {
                context.fillStyle = 'white'
            //}
            context.fill()
        }
    }
    function prepareStar() {
        for(var i=0;i<1;i+=1){
            stars.push({starX : Math.random() * c.width,intensity:Math.random(),blink : Math.random() * 100 >= 80, starY : Math.random() * c.height})
        }
    }
    

            
         
            




g()
</script>